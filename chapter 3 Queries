SQl Query from Murach's SQL Server 2016 for Developers page 89 figure 3-2 #4

--This query demonstrates the use of the Between operator to retrieve data for invoices between two specific dates

SELECT InvoiceNumber, InvoiceDate, InvoiceTotal
FROM Invoices
WHERE InvoiceDate BETWEEN '2016-01-01' AND '2016-05-31'
ORDER BY InvoiceDate;

/*This query selects the Invoicenumber, InvoiceDate, and InvoiceTotal from the Invoices table only including those results 
where the dates fall between January 1st 2016 and May 31st 2016. The reuslts are them placed in order by the date: earliest to latest

------Sample Output: (first ten rows)
InvoiceNumber	InvoiceDate	InvoiceTotal
25022117	2016-01-01 00:00:00	6.00
P02-88D77S7	2016-01-03 00:00:00	856.92
21-4748363	2016-01-03 00:00:00	9.95
4-321-2596	2016-01-05 00:00:00	10.00
963253242	2016-01-06 00:00:00	104.00
QP58872	2016-01-07 00:00:00	116.54
24863706	2016-01-10 00:00:00	6.00
10843	2016-01-11 00:00:00	4901.26
963253235	2016-01-11 00:00:00	108.25
21-4923721	2016-01-13 00:00:00	9.95

Augmented Code:

SELECT InvoiceNumber, InvoiceDate, InvoiceTotal
FROM Invoices
WHERE InvoiceDate >= '2016-01-01' OR InvoiceDate<= '2016-05-31'
ORDER BY InvoiceDate;

I changed this program in the where clause by replacing the Between operator with an AND statement to get data from between the 
same dates. I used the greater than or equal to operator to make sure I get dates that start at the earliest January 1st 2016
and then used the less than or equal to operator to get dates that are at the latest May 31st 2016, with the AND showing it 
can be any date that falls between those two dates. This just shows another way to write the same thing. 

------Augmented Sample Output: (first ten rows)
InvoiceNumber	InvoiceDate	InvoiceTotal
25022117	2016-01-01 00:00:00	6.00
P02-88D77S7	2016-01-03 00:00:00	856.92
21-4748363	2016-01-03 00:00:00	9.95
4-321-2596	2016-01-05 00:00:00	10.00
963253242	2016-01-06 00:00:00	104.00
QP58872	2016-01-07 00:00:00	116.54
24863706	2016-01-10 00:00:00	6.00
10843	2016-01-11 00:00:00	4901.26
963253235	2016-01-11 00:00:00	108.25
21-4923721	2016-01-13 00:00:00	9.95

______________________________________________________________________________________________________________________________________

SQL Query from Murach's SQL Server 2016 for Developers page 99 figure 3-7 #3

--This query demonstrates the use of the GETDATE and DATEDIFF functions to calcuate the age of the Invoices 

SELECT InvoiceDate,
    GETDATE() AS 'Today''s Date',
    DATEDIFF(day, InvoiceDate, GETDATE()) AS Age
FROM Invoices;

/*This query selects the InvoiceDate column but has another column in the result set : Age. Age is determined by the difference 
in the numbe rof days between the InvoiceDate and today's date, which is a column alias determiend by the GETDATE function which 
get's today's date, which is why the column is named that. DATEDIFF is a fucntion that will return a value in days, shown by the first 
paremeter in the parenthesis, and it will be a result of the difference between the 2nd and 3rd paremeter (the date of the original
invoice and today's date). This is all done from the Invoices base table. An important thing to note is that this query will change
as the date changes, so today;s result is and will be different from tomarrow or next year's results. Also, since by default it 
takes the date as the date and 00:00 you should be careful when using this function to make sure ALL dates with different times
are included in the query as well (if thats what you wish)

Sample Output: 
InvoiceDate	          Today's Date	            Age
2016-04-02 00:00:00	  2019-11-04 00:30:29.960 	1311
2016-04-01 00:00:00	  2019-11-04 00:30:29.960	  1312
2016-03-31 00:00:00	  2019-11-04 00:30:29.960	  1313
2016-03-30 00:00:00	  2019-11-04 00:30:29.960	  1314
2016-03-28 00:00:00	  2019-11-04 00:30:29.960	  1316
2016-03-25 00:00:00	  2019-11-04 00:30:29.960	  1319
2016-03-24 00:00:00	  2019-11-04 00:30:29.960	  1320
2016-03-24 00:00:00	  2019-11-04 00:30:29.960	  1320
2016-03-24 00:00:00	  2019-11-04 00:30:29.960	  1320
2016-03-24 00:00:00	  2019-11-04 00:30:29.960	  1320

Augmented Code: 
SELECT InvoiceDate, (InvoiceTotal-PaymentTotal-CreditTotal) AS BalanceDue,
    GETDATE() AS 'Today''s Date',
    DATEDIFF(day, InvoiceDate, GETDATE()) AS Age
FROM Invoices
where InvoiceTotal-PaymentTotal-CreditTotal >0; 

/* I expanded the functionality of the program by adding in what the outstanding balance was so that we could see how old the
invoices were in days that still had a balnce due. So I used the calculation Murach uses repeatedly
((InvoiceTotal-PaymentTotal-CreditTotal) AS BalanceDue) to select that column as well and only include those rows 
in the result set where the BalanceDue was greater than zero (shown by the added where clause).

--------Augmented Sample Output: All 11 rows
 InvoiceDate	BalanceDue	Today's Date	Age
2016-03-10 00:00:00	85.31	2019-11-04 01:14:12.470	1334
2016-03-18 00:00:00	52.25	2019-11-04 01:14:12.470	1326
2016-03-21 00:00:00	579.42	2019-11-04 01:14:12.470	1323
2016-03-21 00:00:00	59.97	2019-11-04 01:14:12.470	1323
2016-03-22 00:00:00	67.92	2019-11-04 01:14:12.470	1322
2016-03-22 00:00:00	30.75	2019-11-04 01:14:12.470	1322
2016-03-23 00:00:00	19351.18	2019-11-04 01:14:12.470	1321
2016-03-24 00:00:00	503.20	2019-11-04 01:14:12.470	1320
2016-03-28 00:00:00	90.36	2019-11-04 01:14:12.470	1316
2016-03-31 00:00:00	10976.06	2019-11-04 01:14:12.470	1313
2016-04-01 00:00:00	224.00	2019-11-04 01:14:12.470	1312  
*/

________________________________________________________________________________________________________________________________

SQL Query from Murach's SQL Server 2016 for Developers page 97 figure 3-6 c

--This query shows how order of operations are a default and can be overriden by parentheses to get completely different values

SELECT InvoiceID,
    InvoiceID + 7 * 3 AS OrderOfPrecedence,
    (InvoiceID + 7) * 3 AS AddFirst
FROM Invoices
ORDER BY InvoiceID;

/*This query shows how the default order of operations gives some value for the InvoiceID after using it in calculations
while the same thing with parenthesus around the adding makes it give different values to the InvoiceID. With order of 
operations, multiplication takes precedence over adding and so if you have addition with it, you will not get the same value
as if you add firstad then multiply. This is all reguarding the InvoiceID from the Invoices table and places the result set 
in order by from the smallest to largest InvoiceID. 

-------Sample Output: First ten rows 
InvoiceID	OrderOfPrecedence	AddFirst
1	            22	                24
2	            23                 	27
3	            24              	30
4	            25	                33
5	            26	                36
6	            27	                39
7	            28	                42
8	            29	                45
9	            30	                48
10	            31	                51

Augmented Code:

SELECT InvoiceID,
    InvoiceID + 7 * 3 AS OrderOfPrecedence,
    (InvoiceID + 7) * 3 AS AddFirst,
	InvoiceID + 7 * 3 /5 AS OrderWithDivision
FROM Invoices
ORDER BY InvoiceID;

Here I added a column OrderWithDivision to show how having division changes the order of operations. Division takes precedence 
over multiplication so when I defined that column as InvoiceID + 7 * 3 /5 AS OrderWithDivision it meant that it would first 
do 3/5, then multiply that result to 7 and then add that result to the InvoiceID. If I did not want this I could put 
parenthesis to clarify what order I DID want it in.

Augmented Sampel Output : First ten rows
InvoiceID	OrderOfPrecedence	AddFirst	OrderWithDivision
1	            22	                24	                5
2	            23	                27	                6
3	            24	                30	                7
4	            25	                33	                8
5	            26	                36	                9
6	            27	                39	                10
7	            28	                42	                11
8	            29	                45	                12
9	            30	                48	                13
10	            31	                51	                14

__________________________________________________________________________________________________________________________________

SQL Query from Murach's SQL Server 2016 for Developers page 103 figure 3-9 a
--This query demonstrates the use of the TOP clause, showing it can retrieve a specific amount of rows from a result set

SELECT TOP 5 VendorID, InvoiceTotal
FROM Invoices
ORDER BY InvoiceTotal DESC;

----------Sample output (all rows) 
VendorID	InvoiceTotal
110         	37966.19
110         	26881.40
110         	23517.58
72          	21842.00
110         	20551.18

This query uses the TOP clause which just retrieves a set number of rows which is specified in this case to be 5. 
So it will select the top 5 rows from the Invoices table, selecting only the VendorID and InvoiceTotal columns and 
only after the the InvoiceTotal largest to smallest. Without the Order by, the query would not be as useful
becuase the rows would be mixed up and essentially would select 5 random rows after applying all the search conditions. 
This will give me the top five highest invoice totals. 

Augmented Code:

SELECT TOP 5 VendorID, InvoiceTotal
FROM Invoices
ORDER BY InvoiceTotal;

I changed the code by ordering the result set by the InvoiceTotal ascending instead of descending,
which will give me the five lowest invoice totals.
This shows the importance of the order by clause when using the TOP clause so that you get meaningful results. 

------Augmented Sample Output (all rows)
VendorID	InvoiceTotal
115	        6.00
115	        6.00
115     	6.00
97	        9.95
97	        9.95

_________________________________________________________________________________________________________________________________







SQL Query 

source: https://www.w3schools.com/sql/trysql.asp?filename=trysql_select_join_left

--This shows a left join between the Customers and Orders table based on the CustomerID, selecting the CustomerName and OrderID column 
--and ordering the result by the first column 

SELECT Customers.CustomerName, Orders.OrderID
FROM Customers
LEFT JOIN Orders
ON Customers.CustomerID=Orders.CustomerID
ORDER BY Customers.CustomerName;

/*This query specifies the column names from both tables that are to be used in the left join by using the format
Table1.ColumnName, Table2.ColumnName. This specification helps clarify what table each column corresponds to
As a left join, it means that all records FROM the customers table are included and those that match to the Orders table
are included as well. The join condition is where the CustomerID matches in both tables. Finally, the results are ORDERed BY the 
CustomerName column that corresponds to the Customers table. 
*/


/*---------Sample Output (first 10 rows) 
CustomerName	                       OrderID
Alfreds Futterkiste	                  null
Ana Trujillo Emparedados y helados	  10308
Antonio Moreno Taquería	              10365
Around the Horn	                      10355
Around the Horn                     	10383
B's Beverages	                        10289
Berglunds snabbköp	                  10278
Berglunds snabbköp	                  10280
Berglunds snabbköp	                  10384
*/

Augmented:
SELECT Customers.CustomerName, Orders.OrderID, Customers.Country
FROM Customers
LEFT JOIN Orders
ON Customers.CustomerID=Orders.CustomerID
where Customers.Country='Germany' or Customers.Country='France' or Customers.Country='Spain'
ORDER BY Customers.CustomerName;

I augmented the program by adding a where clause to filter the results out further, only choosing those customers whose
country was listed as Germany, france, or Spain, and to make this clear I selected the Country column form the Customers table.


-----------Augmented Sample Output (first ten rows)
CustomerName	OrderID	Country
Alfreds Futterkiste 		Germany 
Blauer See Delikatessen 		Germany 
Blondel père et fils 	10360 	France 
Blondel père et fils 	10265 	France 
Blondel père et fils 	10297 	France 
Blondel père et fils 	10436 	France 
Bólido Comidas preparadas 	10326 	Spain 
Bon app' 	10331 	France 
Bon app' 	10340 	France 
Bon app' 	10362 	France 
______________________________________________________________________________________________________________________________________

--Source Code: Murach's SQL Server 2016 for Developers pg 133 figure 4-4
--SQL Query--This demonstrates how to join data from two tables with two join conditions and an order by clause 

SELECT InvoiceNumber, InvoiceDate,
    InvoiceTotal, InvoiceLineItemAmount
FROM Invoices JOIN InvoiceLineItems AS LineItems
    ON (Invoices.InvoiceID = LineItems.InvoiceID) AND
       (Invoices.InvoiceTotal > LineItems.InvoiceLineItemAmount)
ORDER BY InvoiceNumber;
/*

This query selects the InvoiceNumber, InvoiceDate, InvoiceTotal, and InvoiceLine ItemAmount columns to retrieve data from.
It JOINs data from the Invoices and InvoiceLineItems table using an inner join. With an inner join one may write the INNER keyword
but it is not required.The AS shows a column alias, shortening the name of the second table to 
LineItems and then using that throughout the query. There are them two join conditions. The first is that the invoiceID has to match 
in both tables. The second is that the InvoiceTotal from the Invoices table has to be larger than the InvoiceLineItemAmount from 
the LineItems table. 
*/

/*---------Sample Output

InvoiceNumber	InvoiceDate	InvoiceTotal	InvoiceLineItemAmount
97/522	2016-02-28 00:00:00	1962.13	1197.00
97/522	2016-02-28 00:00:00	1962.13	765.13
I77271-O01	2015-12-26 00:00:00	662.00	50.00
I77271-O01	2015-12-26 00:00:00	662.00	75.60
I77271-O01	2015-12-26 00:00:00	662.00	58.40
I77271-O01	2015-12-26 00:00:00	662.00	478.00
*/

Augmented:

SELECT LineItems.InvoiceID, LineItems.AccountNo,
    LineItems.InvoiceLineItemAmount, GLA.AccountDescription
FROM InvoiceLineItems AS LineItems JOIN GLAccounts AS GLA
    ON (LineItems.AccountNo = GLA.AccountNo) 
	AND (LineItems.InvoiceLineItemAmount > 1000)
ORDER BY LineItems.InvoiceID;

*/For my changes I chose to do the join changing which tables I join and changing the conditions. Seelcting
the InvoiceID and LineItemAmount columns from the LineItems table and the AccountDescription column form the GLA table
I joined the InvoiceLineItems with the GLACcounts table, (which was given the alias GLA) instead of joining the Invoices table
with the InvoiceLineItems table.I choose to match up the AccountNo following the format of the first join condition
in the first query and replaced the second join condition a statement that would filter the result set to only include 
those rows with a line item amount of over 1000 (this I could have put as a WHERE clause).
Then I ordered by the InvoiceID from the LineItems table. 

-------Augmented Sample output (first ten rows)
InvoiceID	AccountNo	InvoiceLineItemAmount	AccountDescription
1	553	3813.33	Freight
21	589	4901.26	Outside Services
24	520	1750.00	Building Lease
31	589	7125.34	Outside Services
35	507	1600.00	UCI
39	400	37966.19	Book Printing Costs
43	400	21842.00	Book Printing Costs
45	553	2765.36	Freight
47	572	1575.00	Books, Dues, and Subscriptions
51	553	2184.11	Freight
_______________________________________________________________________________________________________________________________

SQL Query----from Murach's SQL Server 2016 for Developers figure 4-14 page 153

This query joins data from the same table with a UNION clause to determined whether an invoice is paid or active

USE AP; 

    SELECT 'Active' AS Source, InvoiceNumber, InvoiceDate, InvoiceTotal
    FROM Invoices
    WHERE InvoiceTotal - PaymentTotal - CreditTotal > 0
UNION
    SELECT 'Paid' AS Source, InvoiceNumber, InvoiceDate, InvoiceTotal
    FROM Invoices
    WHERE InvoiceTotal - PaymentTotal - CreditTotal <= 0
ORDER BY InvoiceTotal DESC;

*/This query has a syntax with two select statements where all the rows returned by the first set of select statements are 
combined with the rows returned by the second set of select statements, both from the same table. It joins the data and 
differentiates what the paid invoices are with the active ones. This is done by adding a column named Source, which is 
comprised of either: the value 'Active', where the fact that there is still a balance due (shown
by the where clause in the first query) makes it an active invoice, or the value 'Paid', where the fact that their is not
a balance due (shown by the where cause in the second query) makes it a paid invoice. So for the rows that have a outstanding 
balance, they will have a Active in the row for the Source column and htose without one will have a Paid written in place. 
In addition, the colukns InvoiceNumber, InvoiceDate, and InvoiceTotal are selected from the Invoices table. After all of this, the
rows form the two parts of this query are joined together by the UNION to make it one result set and then the results are 
ordered by the InvoiceTotal in descending order.

--------Sample Output: first ten rows
Source	InvoiceNumber	InvoiceDate	InvoiceTotal
Paid	0-2058	2016-01-28 00:00:00	37966.19
Paid	P-0259	2016-03-19 00:00:00	26881.40
Paid	0-2060	2016-03-24 00:00:00	23517.58
Paid	40318	2016-02-01 00:00:00	21842.00
Active	P-0608	2016-03-23 00:00:00	20551.18
Active	0-2436	2016-03-31 00:00:00	10976.06
Paid	P02-377 2016-01-21 00:00:00	7125.34
Paid	509786	2016-02-18 00:00:00	6940.25
Paid	10843	2016-01-11 00:00:00	4901.26
Paid	989319-457 2015-12-08 00:00:00	3813.33

Augmented Code: 
USE AP; 

    SELECT 'Recent' AS Relevance, InvoiceNumber, InvoiceDate, InvoiceTotal
    FROM Invoices
    WHERE InvoiceDate >= '2016-02-01'
UNION
    SELECT 'Old' AS Relevance, InvoiceNumber, InvoiceDate, InvoiceTotal
    FROM Invoices
    WHERE InvoiceDate < '2016-02-01'
ORDER BY InvoiceTotal DESC;

For this I augmented the code by following the same code structure to figure out something else: whether an invoice would be 
considered old or recent based on its date. So I put a search condition in the where clause defining an invoice as 'Recent'
if it was on or after Feburary 1st 2016 and defining one as 'Old' if it was before that date. These values would make up the 
column Relevance, which in the old query was named Source, naming it Relevance to see how relevant the invoice is in terms of time.

-------Augmented Source Code:
Relevance	InvoiceNumber	InvoiceDate	InvoiceTotal
Old	0-2058	2016-01-28 00:00:00	37966.19
Recent	P-0259	2016-03-19 00:00:00	26881.40
Recent	0-2060	2016-03-24 00:00:00	23517.58
Recent	40318	2016-02-01 00:00:00	21842.00
Recent	P-0608	2016-03-23 00:00:00	20551.18
Recent	0-2436	2016-03-31 00:00:00	10976.06
Old	P02-3772	2016-01-21 00:00:00	7125.34
Recent	509786	2016-02-18 00:00:00	6940.25
Old	10843	2016-01-11 00:00:00	4901.26
Old	989319-457	2015-12-08 00:00:00	3813.33

_________________________________________________________________________________________________________________________________
SQL Query---from Murach's SQL Server 2016 for Developers page 155 Figure 4-15 a

--This query demonstrates the EXCEPT clause and how it filters out any customers who happen to be in the employees table as well

USE Examples;

	SELECT CustomerFirst, CustomerLast 
	FROM Customers
EXCEPT
	SELECT FirstName, LastName 
	FROM Employees
ORDER BY CustomerLast;

This is using the examples database. There are two select statements. The first says to select the CustomerFirst and CustomerLast
columns from the Customers table but then the second says to select the FirstName and LastName from the Employees table, when 
actually, this query will filter out any rows if the FirstName and LastName match those in the Customerfirst and CustomerLast columns,
as designated by the EXCEPT. All the rows from the first part of the query EXCEPT those that match up to the results from the second 
query are included in the final result set. 

-----Sample Output: First ten rows
CustomerFirst	CustomerLast
Maria		Anders
Christina	Berglund
Art		Braunschweiger
Donna		Chelan
Fred		Citeaux
Karl		Jablonski
Yoshi		Latimer
Laurence	Lebihan
Elizabeth	Lincoln
Hanna		Moos


____________________________________________________________________________________________________________________________

SQL Query from Murach's SQL Server 2016 for Developers page 155 Figure 4-15 b
--This query shows how to use the intersect clause to only include rows that have matching fields from both set of select statments

USE Examples;

	SELECT CustomerFirst, CustomerLast 
	FROM Customers
INTERSECT
	SELECT FirstName, LastName 
	FROM Employees;
	
This query kind of does the opposite of the EXCEPT Clause. The reuslt of this query is exactly the row that the except query 
takes out of the result yet. In this query, the CustomerFirst and CustomerLast columns of thr Customers table
are selected and if their fields match up with the fields in the FirstName and LastName columns of the Employees table,
then only those corresponding rows go in the result set. So here, Thomas Hardy was the only First and Last name that was matched 
in the Customers and Employees table, so it was the only one included in the result set.

-----Sample Output: all rows (this is the only row in the result set)
CustomerFirst	CustomerLast
Thomas		Hardy

Augmented Code:
Select CustomerFirst, CustomerLast 
	From Customers inner join  Employees
	ON Customers.CustomerFirst=Employees.FirstName
	AND Customers.CustomerLast=Employees.LastName;
	
I changed the program by writing an query with an inner join joining the Customers and Employees tables
that gets the same result as the original query.I used the search condition 
Customers.CustomerFirst=Employees.FirstName AND the condition Customers.CustomerLast=Employees.LastName which 
conceptually is what the intersect operator does becuase if those fields match, only then are those rows inclued in the result set, 
which is what an inner join those. As you can see, both result sets return Thomas Hardy.


-------Augmented Sample Output (all rows..this is the only row in the result set)
CustomerFirst	CustomerLast
Thomas		Hardy
	
__________________________________________________________________________________________________________________________
